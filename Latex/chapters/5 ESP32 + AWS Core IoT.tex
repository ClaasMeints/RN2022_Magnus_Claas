\chapter{ESP32 + \acrshort{aws} Core \acrshort{iot}}\label{ch:5}
\section{\acrshort{aws} Core \acrshort{iot}}\label{sec:5.1}
Wie bereits erwähnt kann für die Anbindung eines \acrshort{iot}-Geräts an die \acrshort{aws}-\Gls{Cloud} der \acrshort{aws} Core \acrshort{iot} Service genutzt werden. Dieser stellt die Basis aller \acrshort{iot} bezogenen \acrshort{aws} Dienste. Damit ein Gerät angebunden werden kann, muss dieses zunächst als \acrshort{iot} Core Gerät in der \acrshort{aws} Console angelegt werden. Bei diesem Prozess werden Zertifikate erstellt, mit denen sich ein Gerät bei \acrshort{aws} authentifizieren kann. Diese können heruntergeladen und in die Gerätesoftware eingebettet werden\cite*[]{AWSIoT}.\\ Um Gerätesoftware für die Anbindung an \acrshort{aws} Core \acrshort{iot} zu entwickeln, bietet \acrshort{aws} unterschiedliche Frameworks und Software Development Kits an. Diese beinhalten vorgegeben Schritte um die Zertifikate einzubinden. Auch die Kommunikation über MQTT mit der \acrshort{aws}-\Gls{Cloud} kann über vorgefertigte Bibliotheken geschehen\cite*[]{AWSSDK}.\\ Bei der Erstellung des Gerätes in der \acrshort{aws} Console wird bereits für jedes Gerät eine API am \acrshort{aws} Core IoT Endpunkt geschaffen. Darüber hinaus bietet der Endpunkt unter \glqq{}/mqtt\grqq\ bereits einen MQTT-Server auf dem \Gls{Topics} erstellt werden können. Mit dem in der Console verfügbaren MQTT-Test-Client kann die Verbindung zu den einzelnen Geräten getestet werden.
\section{Demo-Projekt Quizz-Buzzer}\label{sec:5.2}
Zur Demonstration der Funktionen von \acrshort{aws} Core \acrshort{iot} wird ein Quizz-Buzzer auf Basis eines ESP32 als \acrshort{iot}-Gerät entwickelt. Konkret wird das Entwicklungsboard \glqq{}ESP32-S devkitC V4\grqq\ mit dem ESP-WROOM-32U verwendet. Das Modul verfügt über eine WLAN Schittstelle und zwei Prozessorkerne, sowie eine Vielzahl digitaler Ein- und Ausgänge. Wie in Abbildung~\autoref{fig:5.1} dargestellt werden zwei LEDs über zwei digitale Ausgänge beschaltet und vier Taster an digitale Eingänge geschaltet.
\fig{5.1}{Buzzer auf Basis eines ESP32 (Eigendarstellung)}\FloatBarrier
Der Quizz-Buzzer ist in der Lage einem dem jeweiligen Taster zugeordneten Buchstaben von A bis D per MQTT an ein \Gls{Topics} am Endpunkt in der \acrshort{aws}-Cloud zu schicken. Für die Übertragung wird das JSON-Format genutzt, das Format ist in Abbildung~\autoref{fig:5.2} dargestellt. Wird auf dem gleichen \Gls{Topics} von einem anderen Teilnehmer mit \glqq{}isCorrect\grqq\ geantwortet wird entweder die rote oder die grüne LED für einen kurzen Zeitraum eingeschaltet.\\ Der in gekürzer Fassung in \autoref{sec:code} dargestellte Programmcode für den Buzzer wird mit der \href{https://github.com/platformio/platform-espressif32/tree/master}{Espressif 32: development platform for PlatformIO} und dem \href{https://github.com/aws/aws-iot-device-sdk-embedded-C}{AWS IoT Device SDK for Embedded C} entwickelt. Die Basis für die Kommunikation mit \acrshort{aws} Core \acrshort{iot} ist dabei Beispielprogramm \href{https://github.com/platformio/platform-espressif32/tree/master/examples/espidf-aws-iot}{ESPIDF-AWS-IoT} entnommen.\\ Um die Latenz des Buzzers Möglichst gering zu halten werden jeweils Teile des Programmcodes auf einem der zwei Kerne ausgeführt. Das Handling von WiFi-Events, wie zum Beispiel einem Verbindungsabbruch wird von dem Setup-Code (vgl. \autoref{sec:code}) aus aufgerufen und läuft somit auf Kern 0. Gleiches gilt für die Verarbeitung der Eingangssignale der Taster, die Inerrupts werden dem Kern 0 zugeordnet(vgl. \autoref{sec:code}). Die eigentliche Kommunikation mittels MQTT, sowie das Parsen und erstellen von Strings im JSON-Format wird in einer auf Kern 1 ausgeführten Task bearbeitet(vgl. \autoref{sec:code}).\\
\fig{5.2}{MQTT-Test-Client (Eigendarstellung)}
Um die Information über das Drücken eines Tasters an die Kommunikations-Task zu übermitteln wird eine FreeRTOS-Queue (bereits in der Platform enthalten) verwendet. Wird ein Taster gedrückt, wird die Programmausführung auf Kern 0 unterbrochen und die Interrupt Service Routine ausgeführt. Diese sendet die Information darüber welcher Taster gedrückt wurde an die Queue. Die Kommunikations-Task prüft die Queue zyklisch auf neue Elemente und versendet die entsprechenden Informationen. Dazu wird ein zuvor erstelltes JSON Objekt angepasst und als String mit der \glqq{}publish()\grqq\-Funktion versendet. Durch Auslagerung der Interrupts wird sichergestellt, dass die Kommunikation nicht unterbrochen wird.\FloatBarrier